{"componentChunkName":"component---src-pages-index-js","path":"/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"7ba81867-4280-5d6d-bcb0-5caa4e1554c2","excerpt":"RxJS에서 연산자(operator)는 현재 Observable을 기반으로 새로운 Observable을 생성하는 순수 함수이다. 이때 Observable은 불변 객체이므로 현재의 Observable 인스턴스는 변경되지 않고 항상 새로운 Observable을 만든다. map, filter, reduce 그렇다면 우선 대표적인 연산자인 , , 에 대한 구현을…","frontmatter":{"categories":"RxJS","title":"Operators","date":"August 17, 2021"},"fields":{"slug":"/operators/"}}},{"node":{"id":"fea861e0-9c53-5e79-91dc-ee29a1a0dc69","excerpt":"Observer Pattern 이 무엇인지 이해하기 위해서는 우선 옵서버 패턴(Observer Pattern)에 대한 이해가 필요하다. Loosely Coupling 옵서버 패턴에서는 시간이 경과함에 따라 상태가 변경되는 대상을 Subject라 한다. 또 이때 Subject의 상태 변화를 관찰 혹은 상태 변화에 대한 알림을 받는 대상을 Observer라 …","frontmatter":{"categories":"RxJS","title":"Observable","date":"August 15, 2021"},"fields":{"slug":"/observable/"}}},{"node":{"id":"ad87742e-37d4-58a6-ab53-c0dd1bd8bedd","excerpt":"는 인스턴스를 생성할 때 라는 함수를 인수로 전달받는다. 여기서  함수는 , 라는 함수를 인수로 전달받게 된다. 따라서 와 동일한 인터페이스를 갖는 객체를 만드려면 와 라는 함수를 매개변수로 사용하는 를 전달받을 수 있도록 를 구성해야 할 것이다. 인스턴스를 생성한 이후  내부의 값을 소비(consume)하려면 크게 세 가지 방법을 사용할 수 있다.  가…","frontmatter":{"categories":"자바스크립트","title":"Promise","date":"August 13, 2021"},"fields":{"slug":"/promise-implementation/"}}},{"node":{"id":"1ac3d648-a8ef-574f-8dc2-e1a28fea5e0d","excerpt":"위의 상황에서 코드는 문제없이 동작하지만 많은 요소를 갖는 배열에 대해서는 을 호출할 때마다 즉, 메서드 체이닝을 수행할 때마다 원본 배열과 동일한 크기의 중간 배열을 지속적으로 생성한다는 문제가 있다. 또한 이전 메서드의 호출 결과가 반환되기 이전에는 다음 메서드 호출이 수행되지 않으므로 각 메서드의 수행 시간을 모두 합친 만큼의 blocking이 발생…","frontmatter":{"categories":"자바스크립트","title":"Transducing","date":"August 09, 2021"},"fields":{"slug":"/transducing/"}}},{"node":{"id":"e803c0c9-6228-512f-9623-eab015c794b0","excerpt":"다음 코드의 결과는 무엇인지 확인해보자. 그렇다면 코드가 다음과 같이 수정되었을때 라는 배열의 첫 번째 요소는 이전과 동일하게 1일까? 이는 의 구현에 따라 달라진다. 만약 의 구현이 다음과 같다면 배열의 첫 번째 요소는 4가 될 것이다. 즉, 이는 코드의 순서에 따라 다른 결과를 만들어내게 된 상황인데, 이러한 현상이 발생하는 원인은 인수로 전달한 값이…","frontmatter":{"categories":"자바스크립트","title":"보다 안전한 getter, setter 만들기","date":"August 03, 2021"},"fields":{"slug":"/more-safety-getter-setter/"}}}]},"site":{"siteMetadata":{"language":"ko","author":{"name":"김성백","bio":{"role":"개발자","description":["늘 최선을 다하는","성장을 갈구하는"],"thumbnail":""},"social":{"github":"https://github.com/Baek2back","linkedIn":"","email":"dumbuk12@gmail.com"}}}}},"pageContext":{}},"staticQueryHashes":["1073350324","1562467322","2938748437"]}